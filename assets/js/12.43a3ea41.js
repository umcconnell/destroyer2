(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{291:function(e,t,o){"use strict";o.r(t);var n=o(10),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"room-cleanup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#room-cleanup"}},[e._v("#")]),e._v(" Room Cleanup")]),e._v(" "),t("p",[e._v("Destroyer2 automatically lets open rooms expire after a specified time to keep\nthe database clean. The expiration time in seconds can be set with the\n"),t("code",[e._v("EXPIRE_ROOMS")]),e._v(" key in the "),t("code",[e._v(".env")]),e._v(" file. The default is after 1 day. See the\n"),t("RouterLink",{attrs:{to:"/guide/customizing.html"}},[e._v("customizing section")]),e._v(" for more information on\navailable environment variables.")],1),e._v(" "),t("p",[e._v("Waiting users in an expired room are kicked out. However, rooms never expire\nwhen they are full.")]),e._v(" "),t("p",[e._v("Cleaning up closed rooms in the game-server and the "),t("code",[e._v("openrooms")]),e._v(" list used to\ntrack currently playable rooms is a little more difficult. Destroyer2 uses a\nmultipronged approach to this problem.")]),e._v(" "),t("h2",{attrs:{id:"passive-cleanup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#passive-cleanup"}},[e._v("#")]),e._v(" Passive Cleanup")]),e._v(" "),t("p",[e._v("Expired rooms are deleted from the "),t("code",[e._v("openrooms")]),e._v(" list when this list is read. This\nmeans that calls to the "),t("code",[e._v("api/openrooms")]),e._v(" "),t("RouterLink",{attrs:{to:"/docs/api.html#open-rooms"}},[e._v("endpoint")]),e._v(" clean up\nexpired but still visible zombie rooms.")],1),e._v(" "),t("p",[e._v("However, as this endpoint is cached using the "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since",target:"_blank",rel:"noopener noreferrer"}},[e._v("If-Modified-Since"),t("OutboundLink")],1),e._v(" header, only new users\npassively clean up zombie rooms. This means that existing users might join such\na room, cleaning up the room but causing a user-unfriendly connection error.")]),e._v(" "),t("h2",{attrs:{id:"aggressive-cleanup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aggressive-cleanup"}},[e._v("#")]),e._v(" Aggressive Cleanup")]),e._v(" "),t("p",[e._v("Aggressive cleanup is an optional cleanup mode, where the server actively tries\nto clean up zombie rooms before a users receive an unfriendly error. This\nconsumes a little more ressources.")]),e._v(" "),t("p",[e._v("Aggressive cleanup offers two modes to actively remove expired rooms:")]),e._v(" "),t("ul",[t("li",[e._v("A "),t("strong",[e._v("regular cleanup")]),e._v(" that calls the "),t("RouterLink",{attrs:{to:"/docs/api.html#open-rooms"}},[t("code",[e._v("openrooms")])]),e._v("\nendpoint at regular intervals without cache to activate passive cleanup.\nThis mode can be enabled with the "),t("code",[e._v("CLEANUP_INTERVAL")]),e._v(" key in the "),t("code",[e._v(".env")]),e._v(" file,\nspecifying the interval in seconds, in which the endpoint should be called.")],1)]),e._v(" "),t("p",[e._v("OR")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("A "),t("strong",[e._v("notification listener mode")]),e._v(" that activates Redis\n"),t("a",{attrs:{href:"https://redis.io/topics/notifications",target:"_blank",rel:"noopener noreferrer"}},[e._v("keyspace-event"),t("OutboundLink")],1),e._v(" listeners to clean\nup expired rooms as soon as they are closed. This mode can be activated by\nsetting the "),t("code",[e._v("AGGRESSIVE_CLEANUP")]),e._v(" value in the "),t("code",[e._v(".env")]),e._v(" to "),t("code",[e._v("true")]),e._v(".")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),t("p",[e._v("Keyspace-event listeners are only available since Redis 2.8.0 and might not\nwork in every environment such as Heroku.")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);